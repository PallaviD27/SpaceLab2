# Transmitter Filter
# x = filter_tx(d, usf_filter, switch_graph), API definition 3.4.2
import numpy as np
import matplotlib.pyplot as plt

def filter_tx(d,usf_filter,switch_graph):
    '''
    This function does the filtering of the input signal using a sinc (low-pass filter)
     Parameters:
         d(np.ndarray): Complex valued signal
         usf_filter (int): Upsampling factor
         switch_graph: ON/on to generate the eye diagrams of filtered symbols and OFF/off otherwise
     Returns:
         Filtered_signal: 1D array of filtered symbols
     '''

    usf_filter =8

# Upsampling such that original symbols are at every usf_filter th place
    Upsampled_signal = np.zeros(len(d)*usf_filter,dtype=complex)
    Upsampled_signal[::usf_filter]=d
    print(f'\033[32m\033[1mUp-sampled signal:\033[0m\033[0m {Upsampled_signal}')

# Verify shape of Upsampled Signal
    Upsampled_signal_shape = Upsampled_signal.shape[0]
    print(f'\033[32m\033[1mUpsampled signal shape:\033[0m\033[0m {Upsampled_signal_shape}')

# Ideal low pass filter is rectangular filter in frequency domain and sinc in time domain
# Plot filter
    cut_off = len(d)
    t=np.arange(-1,1,(1.0/(cut_off*usf_filter)))
    ideal_LPFilter = np.sinc(cut_off * t)
    ideal_LPFilter = ideal_LPFilter / np.sum(ideal_LPFilter)
    plt.figure(figsize=(6,6))
    plt.plot(t,ideal_LPFilter,label='sinc(wc * t)')
    plt.xlabel('time', fontweight='bold')
    plt.ylabel('sinc(wc * t)', fontweight = 'bold')
    plt.title ('Low-pass Filter (in time domain)', fontweight='bold')
    plt.grid(True)
    plt.legend()


# Filtered signal generated by convolution with sinc
    filtered_signal = np.convolve(Upsampled_signal,ideal_LPFilter, mode='full')
    print(f'\033[32m\033[1mFiltered Signal:\033[0m\033[0m {filtered_signal} ')

# Normalize signal power to 1
    input_length = cut_off * usf_filter
    Clipped_filtered_signal = filtered_signal[:input_length]
    power = np.mean(np.abs(Clipped_filtered_signal) ** 2)
    Clipped_filtered_signal= Clipped_filtered_signal / np.sqrt(power)  # Normalize to unit power
    print(f'\033[32m\033[1mFiltered Signal (After Normalization):\033[0m\033[0m {Clipped_filtered_signal}')

# Verification that normalised symbols' power is 1
    norm = np.mean(np.abs(Clipped_filtered_signal) ** 2)
    print(f'\033[32m\033[1m Norm of signal: \033[0m\033[0m {norm}')
    Clipped_filtered_signal_shape= Clipped_filtered_signal.shape[0]
    print(f'\033[32m\033[1m Shape of filtered signal:\033[0m\033[0m {Clipped_filtered_signal_shape}')

# Print Eye Diagram
    if switch_graph.upper() == 'ON':
        plt.figure(figsize=(10, 6))
        for p3 in range (Clipped_filtered_signal_shape//8):
            SymbolSetp3 = Clipped_filtered_signal[p3*8:(p3+1)*8]
            print(f'\033[32m\033[1m Symbol Set {p3}: \033[0m\033[0m {SymbolSetp3}')
            AmplitudeSetp3= np.abs(SymbolSetp3)
            t1 = np.arange(0, 8, 1)
            plt.plot(t1,AmplitudeSetp3, label=f'Filtered Signal {p3} Eye Diagram')
        plt.title('Filtered Signal (Low-pass Filter)', fontweight='bold')
        plt.xlabel('Time', fontweight='bold')
        plt.ylabel('Amplitude', fontweight = 'bold')
        plt.legend()
        plt.grid(True)
    else:
        pass


    return Clipped_filtered_signal